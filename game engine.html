<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>MoleScript v1.4</title>
  <style>
    body { font-family: sans-serif; display: flex; gap: 20px; padding: 20px; }
    textarea { width: 300px; height: 400px; font-family: monospace; }
    #canvas { width: 400px; height: 400px; background: #eee; position: relative; }
    .object { position: absolute; width: 40px; height: 40px; text-align: center; line-height: 40px; color: white; font-weight: bold; }
    #console { width: 300px; height: 400px; overflow-y: auto; background: #111; color: #0f0; padding: 10px; font-family: monospace; }
    button { padding: 10px 20px; font-size: 16px; margin-bottom: 10px; }
  </style>
</head>
<body>

  <div>
    <button onclick="runScript()">Start</button>
    <button onclick="openGuide()">Guide</button><br>
    <textarea id="editor">// MoleScript v1.4
spawn "player" as player at 0,0
spawn "wall" as wall at 4,4
spawn "hazard" as lava at 5,5

# pathfinding setup #
pathfind([player], [wall], [lava], 9,9)

loop 10 times:
  step player toward path</textarea>
  </div>

  <div id="canvas"></div>
  <div id="console"></div>

  <script>
    const canvas = document.getElementById('canvas');
    const consoleDiv = document.getElementById('console');
    const editor = document.getElementById('editor');
    const gridSize = 10;
    const objects = {};
    const costMap = Array.from({ length: gridSize }, () => Array(gridSize).fill(1));
    const paths = {};

    function log(msg) {
      consoleDiv.innerHTML += msg + '<br>';
      consoleDiv.scrollTop = consoleDiv.scrollHeight;
    }

    function render() {
      canvas.innerHTML = '';
      for (const name in objects) {
        const obj = objects[name];
        const el = document.createElement('div');
        el.className = 'object';
        el.style.left = obj.x * 40 + 'px';
        el.style.top = obj.y * 40 + 'px';
        el.style.background = obj.type === 'player' ? 'red' :
                              obj.type === 'wall' ? 'black' :
                              obj.type === 'hazard' ? 'orange' : 'blue';
        el.textContent = name;
        canvas.appendChild(el);
      }
    }

    function runScript() {
      consoleDiv.innerHTML = '';
      const raw = editor.value.replace(/#.*?#/g, '');
      const lines = raw.split('\n');
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        if (line.startsWith('spawn')) {
          const match = line.match(/spawn\s+"(\w+)"\s+as\s+(\w+)(?:\s+at\s+(\d+),(\d+))?/);
          if (match) {
            const [_, type, name, x, y] = match;
            const ox = parseInt(x || 0);
            const oy = parseInt(y || 0);
            objects[name] = { type, x: ox, y: oy };
            if (type === 'wall') costMap[oy][ox] = Infinity;
            if (type === 'hazard') {
              costMap[oy][ox] = 20;
              for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                  const nx = ox + dx, ny = oy + dy;
                  if (nx >= 0 && ny >= 0 && nx < gridSize && ny < gridSize && costMap[ny][nx] !== Infinity) {
                    costMap[ny][nx] += 10;
                  }
                }
              }
            }
            log(`Spawned ${type} as ${name} at ${ox},${oy}`);
          }
        } else if (line.startsWith('pathfind')) {
          const match = line.match(/pathfind\(\s*

\[([^\]

]+)\]

,\s*

\[([^\]

]*)\]

,\s*

\[([^\]

]*)\]

,\s*(\d+),\s*(\d+)\)/);
          if (match) {
            const agents = match[1].split(',').map(s => s.trim());
            const walls = match[2].split(',').map(s => s.trim());
            const hazards = match[3].split(',').map(s => s.trim());
            const gx = parseInt(match[4]), gy = parseInt(match[5]);

            for (const name of walls) {
              const obj = objects[name];
              if (obj) costMap[obj.y][obj.x] = Infinity;
            }
            for (const name of hazards) {
              const obj = objects[name];
              if (obj) {
                costMap[obj.y][obj.x] = 20;
                for (let dy = -1; dy <= 1; dy++) {
                  for (let dx = -1; dx <= 1; dx++) {
                    const nx = obj.x + dx, ny = obj.y + dy;
                    if (nx >= 0 && ny >= 0 && nx < gridSize && ny < gridSize && costMap[ny][nx] !== Infinity) {
                      costMap[ny][nx] += 10;
                    }
                  }
                }
              }
            }

            for (const name of agents) {
              const obj = objects[name];
              if (obj) {
                paths[name] = findPath(obj.x, obj.y, gx, gy);
                log(`Path computed for ${name}`);
              }
            }
          }
        } else if (line.startsWith('loop')) {
          const match = line.match(/loop\s+(\d+)\s+times:/);
          if (match) {
            const count = parseInt(match[1]);
            const block = [];
            let j = i + 1;
            while (j < lines.length && lines[j].startsWith('  ')) {
              block.push(lines[j].trim());
              j++;
            }
            for (let k = 0; k < count; k++) {
              block.forEach(cmd => execute(cmd));
            }
            i = j - 1;
          }
        } else {
          execute(line);
        }
      }
      render();
    }

    function execute(line) {
      if (line.startsWith('step')) {
        const match = line.match(/step\s+(\w+)\s+toward\s+path/);
        if (match) {
          const name = match[1];
          const obj = objects[name];
          const path = paths[name];
          if (obj && path && path.length > 0) {
            const next = path.shift();
            obj.x = next.x;
            obj.y = next.y;
            log(`Moved ${name} to ${next.x},${next.y}`);
            render();
          }
        }
      }
    }

    function findPath(sx, sy, gx, gy) {
      const visited = Array.from({ length: gridSize }, () => Array(gridSize).fill(false));
      const cost = Array.from({ length: gridSize }, () => Array(gridSize).fill(Infinity));
      const prev = Array.from({ length: gridSize }, () => Array(gridSize).fill(null));
      cost[sy][sx] = 0;
      const queue = [{ x: sx, y: sy }];
      while (queue.length) {
        queue.sort((a, b) => cost[a.y][a.x] - cost[b.y][b.x]);
        const { x, y } = queue.shift();
        if (visited[y][x]) continue;
        visited[y][x] = true;
        const dirs = [[0,1],[1,0],[0,-1],[-1,0]];
        for (const [dx, dy] of dirs) {
          const nx = x + dx, ny = y + dy;
          if (nx >= 0 && ny >= 0 && nx < gridSize && ny < gridSize && !visited[ny][nx]) {
            const newCost = cost[y][x] + costMap[ny][nx];
            if (newCost < cost[ny][nx]) {
              cost[ny][nx] = newCost;
              prev[ny][nx] = { x, y };
              queue.push({ x: nx, y: ny });
            }
          }
        }
      }

      let path = [];
      let cx = gx, cy = gy;
      while (prev[cy][cx]) {
        path.unshift({ x: cx, y: cy });
        const p = prev[cy][cx];
        cx = p.x;
        cy = p.y;
      }
            return path;
    }

    function openGuide() {
  const guideWindow = window.open("", "MoleScriptGuide", "width=800,height=600");
  const htmlContent = `
    <!DOCTYPE html>
    <html>
    <head>
      <title>MoleScript v1.4 Guide</title>
      <style>
        body { font-family: sans-serif; max-width: 700px; margin: auto; padding: 20px; line-height: 1.6; }
        h1, h2, h3 { color: #c33; }
        code { background: #f4f4f4; padding: 2px 6px; border-radius: 4px; font-family: monospace; }
        pre { background: #f4f4f4; padding: 10px; border-radius: 6px; overflow-x: auto; }
      </style>
    </head>
    <body>
      <h1>ðŸ§­ MoleScript v1.4 Guide</h1>
      <h2>ðŸš€ Core Commands</h2>
      <ul>
        <li><code>spawn "type" as name at x,y</code> â€” create an object</li>
        <li><code>pathfind([agents], [walls], [hazards], goalX, goalY)</code> â€” compute paths</li>
        <li><code>step name toward path</code> â€” move one tile along path</li>
        <li><code>loop N times:</code> â€” repeat a block</li>
        <li><code># comment #</code> â€” inline comment</li>
      </ul>
      <h2>ðŸ§ª Sample Script</h2>
      <pre><code>spawn "player" as player at 0,0
spawn "wall" as wall at 4,4
spawn "hazard" as lava at 5,5

# pathfinding setup #
pathfind([player], [wall], [lava], 9,9)

loop 10 times:
  step player toward path</code></pre>
    </body>
    </html>
  `;
  guideWindow.document.open();
  guideWindow.document.write(htmlContent);
  guideWindow.document.close();
}


  </script>

</body>
</html>
